# Wrangle Data

This chapter contains useful tips on wrangling (i.e., manipulating) data. If you need to know to do to things like create new variables, split one variable into multiple variables, pivot a data set from wide to long, etc., look no further.

## Joining or Splitting

Joining and splitting data is pretty straightforward....

### Data

The code below is from [this excellent tutorial](https://www.youtube.com/watch?v=SCdmyyoudb8&t=23s)

```{r}
set.seed(2018)

df1=data.frame(customer_id=c(1:10),
               product=sample(c('toaster','TV','Dishwasher'),10,replace = TRUE))


df2=data.frame(customer_id=c(sample(df1$customer_id, 5)),state=sample(c('New York','California'),5,replace = TRUE))

df1=as.tibble(df1)
df2=as.tibble(df2)

# df1 =left table
# df2= right table

# inner join - retains only rows with values that appear in both tables, and matches by keys
df1 %>% inner_join(df2,by='customer_id')

# If you're joining two Qualtrics surveys together, this is most likely the one you want to use (e.g. matching by participant name, and only keeping rows in the joined data set for participants that have responses logged in both survey 1 and survey 2

# left join - returns everything in the left, and rows with matching keys in the right
df1 %>% left_join(df2,by='customer_id')

# right join - returns everything in the right, and rows with matching keys in the left
df1 %>% right_join(df2,by='customer_id')


    # note: example if the customer id column was named something different in the second df
    df1 %>% left_join(df2,by=c('customer_id'='name2'))


#full join - retain all rows from both tables, and join matching keys in both right and left
df1 %>% full_join(df2,by='customer_id')

# anti join - returns all rows in the left that do not have matching keys in the right
df1 %>% anti_join(df2,by='customer_id')

```


### Individual Columns/Variables

Splitting or joining columns is much easier than doing it to whole data sets. You can use `dplyr::separate()` to accomplish the former, and `dplyr::unite()` for the latter.

```{r}
print("hello")
```


## Selecting specific columns/variables

Sometimes when working with a data set, you want to work with a few *specific* variables. For instance, maybe you want to view a graph of only reverse-coded variables (which start with the prefix "r"); or maybe you want to create a subset of your data that has a few specific variables removed. For this you can use `dplyr::select()` and its associated helper commands

`select()` can be thought of as "extract"; it tells R to identify and "extract" a specific variable (or variables)


```{r}
cars=mtcars

# select one column
cars %>% select(mpg)

# select multiple columns, if they are all next to one another
cars %>% select(mpg:hp)

# select multiple columns by name (when not next to one another)
cars %>% select(c(mpg, hp, wt))
```


If you need to do some more complex selection (e.g., select all variables that start or end with a certain pattern; all columns that contain a certain pattern; etc.), see [THIS LINK](https://tidyselect.r-lib.org/reference/language.html) for a simple but detailed guide.



## If-then and Case-when

```{r}
"hello"
```


